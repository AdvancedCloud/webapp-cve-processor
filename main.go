package main

import (
	"archive/zip"
	"bytes"
	"encoding/json"
	"fmt"
	"io/ioutil"
	"log"
	"net/http"
	"os"
	"os/exec"
	"reflect"
	"strings"
	"webapp-cve-processor/config"
	"webapp-cve-processor/models"

	"github.com/jmoiron/sqlx"
	_ "github.com/lib/pq"
)

func main() {
	// Load configuration
	cfg := config.LoadConfig()

	// Connect to the default database to create the target database if needed
	defaultDBDSN := fmt.Sprintf("host=%s port=%s user=%s password=%s dbname=postgres sslmode=disable",
		cfg.DBHost, cfg.DBPort, cfg.DBUser, cfg.DBPassword)
	defaultDB, err := sqlx.Open("postgres", defaultDBDSN)
	if err != nil {
		log.Fatalf("Failed to connect to the default database: %v", err)
	}
	defer defaultDB.Close()

	if err := defaultDB.Ping(); err != nil {
		log.Fatalf("Failed to ping the default database: %v", err)
	}

	// Create database if it does not exist
	createDatabaseIfNotExist(defaultDB, cfg.DBName)

	// Run Flyway migration
	if err := runFlywayMigration(cfg); err != nil {
		log.Fatalf("Error running Flyway migration: %v", err)
	}

	// Connect to the target database using a connection pool
	targetDBDSN := cfg.DSN()
	db, err := sqlx.Open("postgres", targetDBDSN)
	if err != nil {
		log.Fatalf("Failed to connect to the target database: %v", err)
	}
	defer db.Close()

	// Set connection pool settings
	db.SetMaxOpenConns(25)
	db.SetMaxIdleConns(25)
	db.SetConnMaxLifetime(0)

	if err := db.Ping(); err != nil {
		log.Fatalf("Failed to ping the target database: %v", err)
	}

	// Download and process CVE list
	downloadAndProcessCVEList(db)

	// Display data stored in the database
	displayStoredData(db)

	// Query and display only changed records
	queryAndDisplayChangedRecords(db)
}

func createDatabaseIfNotExist(db *sqlx.DB, dbName string) {
	var exists bool
	query := "SELECT EXISTS(SELECT datname FROM pg_catalog.pg_database WHERE datname = $1)"
	err := db.Get(&exists, query, dbName)
	if err != nil {
		log.Fatalf("Failed to check if database exists: %v", err)
	}

	if !exists {
		_, err := db.Exec("CREATE DATABASE " + dbName)
		if err != nil {
			log.Fatalf("Failed to create database: %v", err)
		}
		log.Printf("Database %s created successfully.", dbName)
	} else {
		log.Printf("Database %s already exists.", dbName)
	}
}

func runFlywayMigration(cfg config.Config) error {
	fmt.Println("Running Flyway migration...")
	cmd := exec.Command("flyway", "-configFiles=/Users/manavmalavia/Desktop/Advance_cloud/webapp-adv/dbmigration/flyway.conf", "-url=jdbc:postgresql://"+cfg.DBHost+":"+cfg.DBPort+"/"+cfg.DBName,
		"-user="+cfg.DBUser, "-password="+cfg.DBPassword, "migrate")
	cmd.Stdout = os.Stdout
	cmd.Stderr = os.Stderr

	return cmd.Run()
}

func downloadAndProcessCVEList(db *sqlx.DB) {
	resp, err := http.Get("https://github.com/CVEProject/cvelistV5/archive/refs/heads/main.zip")
	if err != nil {
		log.Fatalf("Failed to download CVE list: %v", err)
	}
	defer resp.Body.Close()

	if resp.StatusCode != http.StatusOK {
		log.Fatalf("Failed to download file: %s", resp.Status)
	}

	// Read the zip file
	body, err := ioutil.ReadAll(resp.Body)
	if err != nil {
		log.Fatalf("Failed to read response body: %v", err)
	}

	// Extract the zip file
	zipReader, err := zip.NewReader(bytes.NewReader(body), int64(len(body)))
	if err != nil {
		log.Fatalf("Failed to create zip reader: %v", err)
	}

	// Iterate through the files in the zip archive
	for _, file := range zipReader.File {
		if strings.HasSuffix(file.Name, ".json") {
			f, err := file.Open()
			if err != nil {
				log.Fatalf("Failed to open file %s: %v", file.Name, err)
			}

			jsonData, err := ioutil.ReadAll(f)
			f.Close()
			if err != nil {
				log.Fatalf("Failed to read file %s: %v", file.Name, err)
			}

			var singleCVE models.CVE
			var multipleCVEs []models.CVE

			// Attempt to unmarshal as a single CVE object
			singleErr := json.Unmarshal(jsonData, &singleCVE)
			if singleErr == nil {
				storeCVERecord(db, singleCVE)
				continue
			}

			// Attempt to unmarshal as an array of CVE objects
			multipleErr := json.Unmarshal(jsonData, &multipleCVEs)
			if multipleErr == nil {
				for _, cve := range multipleCVEs {
					storeCVERecord(db, cve)
				}
				continue
			}

			log.Printf("Failed to unmarshal JSON: %v; singleErr: %v; multipleErr: %v", err, singleErr, multipleErr)
		}
	}
}

func storeCVERecord(db *sqlx.DB, cve models.CVE) {
	tx := db.MustBegin()

	// Retrieve the latest version of the CVE
	var latestRecord struct {
		JSONData string `db:"json_data"`
		Version  int    `db:"version"`
	}
	query := "SELECT json_data, version FROM cve.cve_records WHERE cve_id = $1 ORDER BY version DESC LIMIT 1"
	err := db.Get(&latestRecord, query, cve.Metadata.CVEID)

	// Marshal the new CVE data to JSON
	newJSONData, err := json.Marshal(cve)
	if err != nil {
		log.Fatalf("Failed to marshal CVE: %v", err)
	}

	// Compare the new JSON data with the latest stored JSON data
	if latestRecord.JSONData != "" {
		if isJSONEqual(latestRecord.JSONData, string(newJSONData)) {
			log.Printf("No changes detected for CVE ID %s. Skipping insertion.", cve.Metadata.CVEID)
			return
		}
	} else {
		log.Printf("No previous record found for CVE ID %s. Inserting new record.", cve.Metadata.CVEID)
	}

	// Increment the version if a previous record exists
	version := 1
	if latestRecord.JSONData != "" {
		version = latestRecord.Version + 1
	}

	// Check if the version already exists to avoid conflicts
	var existingCount int
	checkVersionQuery := "SELECT COUNT(*) FROM cve.cve_records WHERE cve_id = $1 AND version = $2"
	err = db.Get(&existingCount, checkVersionQuery, cve.Metadata.CVEID, version)
	if err != nil {
		tx.Rollback()
		log.Fatalf("Failed to check existing version: %v", err)
	}

	if existingCount > 0 {
		version = version + 1
	}

	// Insert the new version of the CVE record
	insertQuery := `INSERT INTO cve.cve_records (cve_id, json_data, version, date_updated)
                    VALUES ($1, $2, $3, $4)`
	_, err = tx.Exec(insertQuery, cve.Metadata.CVEID, newJSONData, version, cve.Metadata.DateUpdated.Time)
	if err != nil {
		tx.Rollback()
		log.Fatalf("Failed to insert CVE record: %v", err)
	}

	tx.Commit()
	log.Printf("CVE record for %s stored successfully, version %d.", cve.Metadata.CVEID, version)
}

func isJSONEqual(json1, json2 string) bool {
	var obj1, obj2 map[string]interface{}

	err1 := json.Unmarshal([]byte(json1), &obj1)
	err2 := json.Unmarshal([]byte(json2), &obj2)

	if err1 != nil || err2 != nil {
		log.Printf("Error unmarshalling JSON for comparison: %v, %v", err1, err2)
		return false
	}

	return reflect.DeepEqual(obj1, obj2)
}

func displayStoredData(db *sqlx.DB) {
	var records []struct {
		CVEID       string `db:"cve_id"`
		JSONData    string `db:"json_data"`
		Version     int    `db:"version"`
		DateUpdated string `db:"date_updated"`
	}

	err := db.Select(&records, "SELECT cve_id, json_data, version, date_updated FROM cve.cve_records")
	if err != nil {
		log.Fatalf("Failed to fetch records: %v", err)
	}

	log.Println("Stored CVE Records:")
	for _, record := range records {
		log.Printf("CVE ID: %s, Version: %d, Date Updated: %s, JSON Data: %s", record.CVEID, record.Version, record.DateUpdated, record.JSONData)
	}
}

func queryAndDisplayChangedRecords(db *sqlx.DB) {
	var records []struct {
		CVEID       string `db:"cve_id"`
		JSONData    string `db:"json_data"`
		Version     int    `db:"version"`
		DateUpdated string `db:"date_updated"`
	}

	query := `
        SELECT cve_id, json_data, version, date_updated 
        FROM cve.cve_records 
        WHERE cve_id IN (
            SELECT cve_id 
            FROM cve.cve_records 
            GROUP BY cve_id 
            HAVING COUNT(*) > 1
        )
        ORDER BY cve_id, version`
	err := db.Select(&records, query)
	if err != nil {
		log.Fatalf("Failed to fetch changed records: %v", err)
	}

	log.Println("Changed CVE Records:")
	for _, record := range records {
		log.Printf("CVE ID: %s, Version: %d, Date Updated: %s, JSON Data: %s", record.CVEID, record.Version, record.DateUpdated, record.JSONData)
	}
}
